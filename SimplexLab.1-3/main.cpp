
#pragma warning (disable:4996)
#include <iostream>
#include <conio.h>
#include <iomanip> 
#include <fstream>
#include <Windows.h>
#include <vector>
#include <locale.h>
#include <vector>
#include "tree.h"

using namespace std;
typedef TreeNode<float**> FloatTreeNode;
typedef std::vector<std::vector<float>> Matrix;
typedef TreeNode<Matrix> MatrixNode;


std::ostream& print_array(Matrix& a);


enum Labs
{
	LAB_1,
	LAB_2,
	LAB_3,
	LAB_MAX = LAB_3 
};


float simplex_method_min(Matrix &a){
	int lines = a.size(); //LINES
	int rows = a[0].size(); //ROWS



	int r, k;	//эюьхЁа ╨. ёЄЁюъш ш ёЄюысЎ
	float RP;	//переменная Р. элемента


	while (1)
	{
		r = k = -1;
		//ищем разрешающие столбец и строку по столбцу констант
		float min = 100000;
		for (int i = 0; i < lines - 1; i++)
			if (a[i][0] < 0)
				for (int j = 1; j < rows; j++)
					if (a[i][j] < 0 && (a[i][0] / a[i][j]) < min)
					{
			r = i;
			k = j;
			RP = a[i][j];
			min = (a[i][0] / a[i][j]);
					}

		//ищем разрешающие столбец и строку по строке функции
		min = 0;
		bool flag = 1;
		if (r == -1 || k == -1)
		{

			int max = 100000;
			int min_pos = -1;

			do
			{
				r = -1; k = -1;
				for (int i = 1; i < rows; i++)
				{
					if (abs(a[lines - 1][i]) > min && abs(a[lines - 1][i]) < max && a[lines - 1][i] < 0) //&& ((&& direct) || (a[lines - 1][i] > 0 && !direct)))
					{
						min = abs(a[lines - 1][i]);
						min_pos = i;
					}
				}

				if (min_pos > 0)
				{
					k = min_pos;
					max = abs(a[lines - 1][k]);
				}
				else{
					break;
				}

				min = 100000;
				min_pos = -1;
				for (int j = 0; j < lines - 1; j++)
				{
					if ((min > a[j][0] / a[j][k]) && ((a[j][0] / a[j][k]) > 0))
					{
						min = a[j][0] / a[j][k];
						min_pos = j;
					}
				}

				if (min_pos >= 0)
					r = min_pos;

			} while (r == -1 && k == -1);



		}

		//проверка на наличие Р. столбца, строки
		if (r == -1 || k == -1)
			break;
		RP = a[r][k];

		std::cout << "ёЄЁюър:  " << r + 1 << "	||	ёЄюысхЎ: " << k + 1;
		//расчет коэффициентов вне Р. столбца, строки
		for (int i = 0; i < lines; i++)
			if (i != r)
				for (int j = 0; j < rows; j++)
					if (j != k)
						a[i][j] -= a[i][k] * a[r][j] / RP;

		a[r][k] = 1 / a[r][k]; // a[r][k] -> a*[r][k]

		//расчет Р. строки
		for (int j = 0; j < rows; j++)
			if (j != k)
				a[r][j] = a[r][j] / RP;

		//расчет Р. столбеца
		for (int i = 0; i < lines; i++)
			if (i != r)
				a[i][k] = a[i][k] / RP*(-1);

		//смотрим, оптимальное ли это решение (по колличеству отрицательных элементов в функции)
		int count = 0;
		for (int j = 1; j <rows; j++)
			if (a[lines - 1][j] <= 0)
				count++;

		std::cout << endl;
		print_array(a);
		std::cout << endl;

		//выводим результат и выходим из цикла, если решение оптимально
		if (count == rows - 1)
			break;
	}
	//вывод получившегося ответа
	std::cout << "╬ЄтхЄ: " << a[lines - 1][0] << endl << endl << "----------------------------------------------------------------------------" << endl;
	return a[lines - 1][0];
}


float simplex_method(Matrix& a, bool &is_failed){
	int lines = a.size(); //LINES
	int rows = a[0].size(); //ROWS
	//┬эрўрых - Єшяр чрЇхщыхэ
	is_failed = false;


	int r, k;	//номера Р. строки и столбца
	float RP;	//переменная Р. элемента


	while (1)
	{
		is_failed = true;
		for (int i = 1; i < rows && is_failed; i++)
			if (a[lines - 1][i] < 0)
				is_failed = false;
		if (is_failed) {
			int j;
			for ( j = 0; (j < lines - 1) && is_failed; j++)
				if (a[j][0] < 0) {
					int i;
					for ( i = 1; (i < rows) && is_failed; i++)
						if (a[j][i] < 0)
							is_failed = false;
					if (i == rows) {
						is_failed = true;
						break;
					}
				}

			if (j == lines - 1)
				is_failed = false;

			if (is_failed)
				return 0;
		}

		r = k = -1;
		//ищем разрешающие столбец и строку по столбцу констант
		float min = 100000;
		for (int i = 0; i < lines - 1; i++)
			if (a[i][0] < 0)
				for (int j = 1; j < rows; j++)
					if (a[i][j] < 0 && (a[i][0] / a[i][j]) < min)
					{
						r = i;
						k = j;
						RP = a[i][j];
						min = (a[i][0] / a[i][j]);
					}

		//ищем разрешающие столбец и строку по строке функции		
		
		if (r == -1 || k == -1)
		{
			bool flag = 1;
			min = 0;
			int max = 100000;
			int min_pos = -1;

			do
			{
				r = -1; k = -1;
				for (int i = 1; i < rows; i++)
				{
					if (abs(a[lines - 1][i]) > min && abs(a[lines - 1][i]) < max && a[lines - 1][i] < 0) //&& ((&& direct) || (a[lines - 1][i] > 0 && !direct)))
					{
						min = abs(a[lines - 1][i]);
						min_pos = i;
					}
				}
				
				if (min_pos > 0)
				{
					k = min_pos;
					max = abs(a[lines - 1][k]);
				}
				else{
					break;
				}
					
				min = 100000;
				min_pos = -1;
				for (int j = 0; j < lines - 1; j++)
				{
					if ((min > a[j][0] / a[j][k]) && ((a[j][0] / a[j][k] ) > 0))
					{
						min = a[j][0] / a[j][k];
						min_pos = j;
					}
				}

				if (min_pos >= 0)
					r = min_pos;
									
			} while (r == -1 && k == -1);		


			
		}

		//проверка на наличие Р. столбца, строки
		if (r == -1 || k == -1)
			break;

		RP = a[r][k];

		std::cout << "ёЄЁюъра:  " << r + 1 << "	||	ёЄюысхЎ: " << k + 1;
		//расчет коэффициентов вне Р. столбца, строки
		for (int i = 0; i < lines; i++)
			if (i != r)
			for (int j = 0; j < rows; j++)
					if (j != k)
						a[i][j] -= a[i][k] * a[r][j] / RP;

		a[r][k] = 1 / a[r][k]; // a[r][k] -> a*[r][k]

		//расчет Р. строки
		for (int j = 0; j < rows; j++)
			if (j != k)
				a[r][j] = a[r][j] / RP;

		//расчет Р. столбеца
			for (int i = 0; i < lines; i++)
		if (i != r)
			a[i][k] = a[i][k] / RP*(-1);

		//смотрим, оптимальное ли это решение (по колличеству отрицательных элементов в функции)
		int count = 0;
		for (int j = 1; j <rows; j++)
		if (a[lines - 1][j] <= 0) // a[m-1][j] <= 0
			count++;

		std::cout << endl;
		print_array(a);
		std::cout << endl;

		//выводим результат и выходим из цикла, если решение оптимально
		if (count == rows-1)
			break;
	}
	//вывод получившегося ответа
	std::cout << "╬ЄтхЄ " << a[lines - 1][0] << endl << endl << "----------------------------------------------------------------------------" << endl;
	return a[lines - 1][0];
}


Matrix adv_transp(Matrix& a) {  
	size_t rows = a[0].size(),
		   lines = a.size();

	int i, j;
	Matrix b;
	
	b.resize(rows);
	for (i = 0; i < rows; ++i){
		b[i].resize(lines);
	}

	
	for (i = 0; i < lines-1; ++i)
		b[rows - 1][i+1] = a[i][0];
	
	for (i = 1; i < rows; ++i)
		for (j = 1; j < lines; ++j)
			b[i - 1][j] = a[j - 1][i];
	
	for (i = 1; i < rows; ++i)
		b[i - 1][0] = a[lines - 1][i];
	
	for (i = 0; i < rows-1; ++i)
		for (j = 0; j < lines; ++j)
			b[i][j] *= -1;



	return b;
}

 
Labs matrix_interface(Matrix &a, int &rows, int &lines){
	Labs choice;
	int t;
	bool err_flag = false;
	std::ifstream f("in.txt");
	f >> lines >> rows;

	//ёючфрэшх ьрЄЁшЎ√
	//т√фхы хь ярь Є№
	a.resize(lines);
	//ттюф ьрЄЁшЎ√
	for (int i = 0; i < lines; i++) {
		a[i].resize(rows);
		for (int j = 0; j < rows; j++)
			f >> (a)[i][j];
	}
	do {
		std::cout << "┬тхфшЄх эюьхЁ ырсюЁрЄюЁющ ЁрсюЄ√:	1-" << (Labs::LAB_MAX + 1) << endl; //шэфхъё ё эєы 
		cin >> t;
		choice = (Labs)(t - 1); //ъюэтхЁЄшЁєхь т t
		if ((err_flag = (choice >= Labs::LAB_MAX + 1 || t <= 0)))
			std::cout << "╬°шсър, яютЄюЁшЄх ттюф" << endl;
	} while (err_flag);

	f.close();
	return choice;
};


std::ostream& print_array(Matrix &a){
	cout << endl;
	cout.precision(2);
	size_t n = a.size(), m = a[0].size();
	for (size_t i = 0; i < n; i++)
	{
		for (size_t j = 0; j < m; j++)
			cout << std::setw(8) << a[i][j] << "  ";
		cout << endl;
	}
	cout << endl;
	return cout;
}

//тючтЁр∙рхЄ ЄЁє, хёыш тхё№ яхЁт√щ ёЄюысхЎ - Ўхыюўшёыхээ√щ
//is_f_integer -  ты хЄё  ыш f - Ўхы√ь
bool is_integer(float a){
	if (abs(a) < 0.01) //┴█─╦╬╩╬─ ─╦▀ 0
		return true;
	return abs(ceilf(a) - a) < 0.01;
}


bool check_solution_integer(Matrix &a, bool &is_f_integer){
	size_t lines = a.size();

	for (size_t i = 0; i < lines - 1; ++i)
		if (!is_integer(a[i][0]))
			return false;

	is_f_integer = is_integer(a[lines - 1][0]);
	return true;

}

void splitChildren(MatrixNode &node){

	bool is_integer;  // ╩юършэ чфхё№!
	Matrix m = *node;
	int line_num;
	MatrixNode child_1(m), child_2(m);
	size_t i, lines = m.size(), rows = m[0].size();
	std::vector<float> line_to_add, line_to_add_ceil;
	// т√ёырщъштрх°№ё , ырыър! эх уюцх Єръ! ╥ръ шыш эх Єръ?
	for (i = 0; i < lines - 1; ++i) // └ыш° ъюъюрыш°y ъюъюрыш°
		if (ceilf(m[i][0]) != m[i][0])
		{
			line_num = i;
			line_to_add.resize(rows);
			line_to_add_ceil.resize(rows);
			for (int j = 0; j < rows; j++)
				if (j == 0)
				{
					line_to_add[j] = floorf(m[line_num][j])-m[line_num][j];
					line_to_add_ceil[j] = m[line_num][j]-ceilf(m[line_num][j]);    //Deutschland!!!!!! Deutschland !!!! and rabbits :3
				}
				else {
					line_to_add_ceil[j] = m[line_num][j];
					line_to_add[j] = -(m[line_num][j]);
				}
			//т√їюфшь шч Ўшъыр
			break;
		}

	//фюсрты хь т яЁхфяюёыхфэ■■ ёЄЁюъє
	(*child_1).insert((*child_1).begin() + (*child_1).size() - 1, line_to_add);
	(*child_2).insert((*child_2).begin() + (*child_2).size() - 1, line_to_add_ceil);
	node.addChild(child_1);
	node.addChild(child_2);

	//╩юършэ єїюфш!
}

bool recursive_integer_method(MatrixNode &entryNode, Matrix& best){
	bool failed = false;
	float sm = simplex_method(*entryNode, failed);
	cout << "╧юёых ёшьяыхъё-ьхЄюфр" << std::endl;
	print_array(*entryNode);
	if (failed)
		return false;

	
	
	bool  is_integer, f_integer = false;
	//хёыш Ўхыюх ўшёыю шч ёшьяыхъёр ш ёрьш ъю¤Ї-Є√ Ўхы√х, ш тююс∙х сюы№°х схёЄр, шыш є схёЄр эхЎхы√х ъю¤Ї-Є√ шыш ёшьяыхъё, Єю ьхэ хь схёЄ эр эр°
	if ((is_integer = check_solution_integer(*entryNode, f_integer)) && f_integer
		&& (sm>best[best.size() - 1][0] || !check_solution_integer(best, f_integer) || !f_integer))  //рЄшЎ тёхї єёыютшщ!
		best = *entryNode;
	//ёяышЄєхь, ярЁэш!!!
	if (!is_integer)
		splitChildren(entryNode);
	size_t l = entryNode.length();
	for (size_t i = 0; i < l; ++i) {
		cout << "╨хсхэюъ:> " << i << std::endl;
		print_array(**entryNode.getChild(i));
		cout << "----------------------------------" << std::endl;
		if (recursive_integer_method(*entryNode.getChild(i), best))
			is_integer = true;
	}
		

	//тючтЁр∙рхь false, хёыш фЁюсэюх
	return is_integer;
};


void main() {
	setlocale(LC_ALL, "Russian");
	int rows, lines;
	bool failed = false; //хёЄ№ ыш Ёх°хэшх
	Matrix a;
	Labs choice = matrix_interface(a, rows, lines);

	//ъюяшЁютрэшх
	Matrix a_s = a;

	for (int j = 0; j < rows; j++)
		a_s[lines - 1][j] *= -1;
	//Ёх°рхь ╧╟ (1-3 ырс√)
	cout << "╘юЁьєышЁютър яЁ ьющ чрфрўш:";
	print_array(a_s);
	float r1 = simplex_method(a_s, failed);


	if (choice == LAB_2)
	{
		Matrix b = adv_transp(a);
		cout << "╘юЁьєышЁютър ─тющёЄтхээющ чрфрўш: " << endl;
		print_array(b);
		float r2 = -simplex_method_min(b);
		cout << "─тющёЄтхээр  чрфрўр: " << r2 << endl;
		if (r1 == r2)
			cout << "╨х°хэшх фтющёЄтхээющ чрфрўш Ёртэю Ёх°хэш■ яЁ ьющ чрфрўш";
	}

	if (choice == LAB_3){
		bool needed = true;
		bool  is_f_integer = false;
		MatrixNode parent(a_s);
		Matrix best_match = a_s;
		float best_match_simplex;
		//best_match - ыєў°хх Ёх°хэшх, эр фрээ√щ ьюьхэЄ.
		if (check_solution_integer(a_s, is_f_integer) && is_f_integer) {
			best_match_simplex = r1;
		}
		else {
			//╨╚╩╩╩╙╙╙╙╙╨╤╤╚╚╚╚╚▀▀▀▀
			failed = !recursive_integer_method(parent, best_match);
			best_match_simplex = best_match[best_match.size() - 1][0];
		}


		//т√тюфшь Ёхчєы№ЄрЄ
		if (!failed) {
			print_array(best_match);
			cout << "╓хыюўшёыхээр  чрфрўр: " << best_match_simplex << endl;
			parent.clear();
		}
		else
			cout << "╓хыюўшёыхээр  чрфрўр эх шьххЄ Ёх°хэшщ!" << endl;

	}

	getch();
}



//http://www.youtube.com/watch?v=yzZg6ZpHHY4